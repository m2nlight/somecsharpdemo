<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="rtf" xml:space="preserve">
    <value>{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fnil\fcharset1 Courier New;}{\f1\fnil\fcharset1 Comic Sans MS;}}{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red128\green128\blue128;\red0\green127\blue0;\red63\green112\blue63;\red0\green127\blue127;\red0\green0\blue127;\red127\green0\blue127;\red128\green64\blue128;\red127\green127\blue0;\red224\green192\blue224;\red224\green255\blue224;\red63\green127\blue63;\red224\green240\blue255;\red176\green0\blue64;\red48\green96\blue160;\red128\green64\blue32;}
\f0\fs20\cf0 \f1\fs18\cf3 /* Aho-Corasick text search algorithm implementation\par
 * \par
 * For more information visit\par
 *     - http://www.cs.uku.fi/~kilpelai/BSA05/lectures/slides04.pdf\par
 */\f0\fs20\cf2 \par
\cf6\b using\cf2\b0  \cf0 System\b ;\cf2\b0 \par
\cf6\b using\cf2\b0  \cf0 System\b .\b0 Collections\b ;\cf2\b0 \par
\par
\cf6\b namespace\cf2\b0  \cf0 EeekSoft\b .\b0 Text\cf2 \par
\cf0\b \{\cf2\b0 \par
   \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2    \f1\fs18\cf4 /// Interface containing all methods to be implemented\par
\f0\fs20\cf2    \f1\fs18\cf4 /// by string search algorithm\par
\f0\fs20\cf2    \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2    \cf6\b public\cf2\b0  \cf6\b interface\cf2\b0  \cf0 IStringSearchAlgorithm\cf2 \par
   \cf0\b \{\cf2\b0 \par
       \cf9 #region Methods &amp; Properties\par
\cf2 \par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// List of keywords to search for\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b string\cf0 []\cf2\b0  \cf0 Keywords\cf2  \cf0\b \{\cf2\b0  \cf0 get\b ;\cf2\b0  \cf0 set\b ;\cf2\b0  \cf0\b \}\cf2\b0 \par
       \par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Searches passed text and returns all occurrences of any keyword\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;param name="text"&gt;Text to search&lt;/param&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;returns&gt;Array of occurrences&lt;/returns&gt;\par
\f0\fs20\cf2        \cf0 StringSearchResult\b []\cf2\b0  \cf0 FindAll\b (\cf6 string\cf2\b0  \cf0 text\b );\cf2\b0 \par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Searches passed text and returns first occurrence of any keyword\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;param name="text"&gt;Text to search&lt;/param&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;returns&gt;First occurrence of any keyword (or StringSearchResult.Empty if text doesn't contain any keyword)&lt;/returns&gt;\par
\f0\fs20\cf2        \cf0 StringSearchResult\cf2  \cf0 FindFirst\b (\cf6 string\cf2\b0  \cf0 text\b );\cf2\b0 \par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Searches passed text and returns true if text contains any keyword\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;param name="text"&gt;Text to search&lt;/param&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;returns&gt;True when text contains any keyword&lt;/returns&gt;\par
\f0\fs20\cf2        \cf6\b bool\cf2\b0  \cf0 ContainsAny\b (\cf6 string\cf2\b0  \cf0 text\b );\cf2\b0 \par
\par
       \cf9 #endregion\par
\cf2    \cf0\b \}\cf2\b0 \par
\par
   \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2    \f1\fs18\cf4 /// Structure containing results of search \par
\f0\fs20\cf2    \f1\fs18\cf4 /// (keyword and position in original text)\par
\f0\fs20\cf2    \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2    \cf6\b public\cf2\b0  \cf6\b struct\cf2\b0  \cf0 StringSearchResult\cf2 \par
   \cf0\b \{\cf2\b0 \par
       \cf9 #region Members\par
\cf2        \par
       \cf6\b private\cf2\b0  \cf6\b int\cf2\b0  \cf0 _index\b ;\cf2\b0 \par
       \cf6\b private\cf2\b0  \cf6\b string\cf2\b0  \cf0 _keyword\b ;\cf2\b0 \par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Initialize string search result\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;param name="index"&gt;Index in text&lt;/param&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;param name="keyword"&gt;Found keyword&lt;/param&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf0 StringSearchResult\b (\cf6 int\cf2\b0  \cf0 index\b ,\cf6 string\cf2\b0  \cf0 keyword\b )\cf2\b0 \par
       \cf0\b \{\cf2\b0 \par
           \cf0 _index\b =\b0 index\b ;\cf2\b0  \cf0 _keyword\b =\b0 keyword\b ;\cf2\b0 \par
       \cf0\b \}\cf2\b0 \par
\par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Returns index of found keyword in original text\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf6\b int\cf2\b0  \cf0 Index\cf2 \par
       \cf0\b \{\cf2\b0 \par
           \cf0 get\cf2  \cf0\b \{\cf2\b0  \cf6\b return\cf2\b0  \cf0 _index\b ;\cf2\b0  \cf0\b \}\cf2\b0 \par
       \cf0\b \}\cf2\b0 \par
\par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Returns keyword found by this result\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf6\b string\cf2\b0  \cf0 Keyword\cf2 \par
       \cf0\b \{\cf2\b0 \par
           \cf0 get\cf2  \cf0\b \{\cf2\b0  \cf6\b return\cf2\b0  \cf0 _keyword\b ;\cf2\b0  \cf0\b \}\cf2\b0 \par
       \cf0\b \}\cf2\b0 \par
\par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Returns empty search result\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf6\b static\cf2\b0  \cf0 StringSearchResult\cf2  \cf0 Empty\cf2 \par
       \cf0\b \{\cf2\b0 \par
           \cf0 get\cf2  \cf0\b \{\cf2\b0  \cf6\b return\cf2\b0  \cf6\b new\cf2\b0  \cf0 StringSearchResult\b (-\cf5\b0 1\cf0\b ,\cf7\b0 ""\cf0\b );\cf2\b0  \cf0\b \}\cf2\b0 \par
       \cf0\b \}\cf2\b0 \par
\par
       \cf9 #endregion\par
\cf2    \cf0\b \}\cf2\b0 \par
\par
\par
   \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2    \f1\fs18\cf4 /// Class for searching string for one or multiple \par
\f0\fs20\cf2    \f1\fs18\cf4 /// keywords using efficient Aho-Corasick search algorithm\par
\f0\fs20\cf2    \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2    \cf6\b public\cf2\b0  \cf6\b class\cf2\b0  \cf0 StringSearch\cf2  \cf0\b :\cf2\b0  \cf0 IStringSearchAlgorithm\cf2 \par
   \cf0\b \{\cf2\b0 \par
       \cf9 #region Objects\par
\cf2 \par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Tree node representing character and its \par
\f0\fs20\cf2        \f1\fs18\cf4 /// transition and failure function\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b class\cf2\b0  \cf0 TreeNode\cf2 \par
       \cf0\b \{\cf2\b0 \par
           \cf9 #region Constructor &amp; Methods\par
\cf2 \par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Initialize tree node with specified character\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;param name="parent"&gt;Parent node&lt;/param&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;param name="c"&gt;Character&lt;/param&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf0 TreeNode\b (\b0 TreeNode\cf2  \cf0 parent\b ,\cf6 char\cf2\b0  \cf0 c\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 _char\b =\b0 c\b ;\cf2\b0  \cf0 _parent\b =\b0 parent\b ;\cf2\b0 \par
               \cf0 _results\b =\cf6 new\cf2\b0  \cf0 ArrayList\b ();\cf2\b0 \par
               \cf0 _resultsAr\b =\cf6 new\cf2\b0  \cf6\b string\cf0 []\cf2\b0  \cf0\b \{\};\cf2\b0 \par
\par
               \cf0 _transitionsAr\b =\cf6 new\cf2\b0  \cf0 TreeNode\b []\cf2\b0  \cf0\b \{\};\cf2\b0 \par
               \cf0 _transHash\b =\cf6 new\cf2\b0  \cf0 Hashtable\b ();\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
\par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Adds pattern ending in this node\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;param name="result"&gt;Pattern&lt;/param&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf6\b void\cf2\b0  \cf0 AddResult\b (\cf6 string\cf2\b0  \cf0 result\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf6\b if\cf2\b0  \cf0\b (\b0 _results\b .\b0 Contains\b (\b0 result\b ))\cf2\b0  \cf6\b return\cf0 ;\cf2\b0 \par
               \cf0 _results\b .\b0 Add\b (\b0 result\b );\cf2\b0 \par
               \cf0 _resultsAr\b =(\cf6 string\cf0 [])\b0 _results\b .\b0 ToArray\b (\cf6 typeof\cf0 (\cf6 string\cf0 ));\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Adds trabsition node\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;param name="node"&gt;Node&lt;/param&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf6\b void\cf2\b0  \cf0 AddTransition\b (\b0 TreeNode\cf2  \cf0 node\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 _transHash\b .\b0 Add\b (\b0 node\b .\b0 Char\b ,\b0 node\b );\cf2\b0 \par
               \cf0 TreeNode\b []\cf2\b0  \cf0 ar\b =\cf6 new\cf2\b0  \cf0 TreeNode\b [\b0 _transHash\b .\b0 Values\b .\b0 Count\b ];\cf2\b0 \par
               \cf0 _transHash\b .\b0 Values\b .\b0 CopyTo\b (\b0 ar\b ,\cf5\b0 0\cf0\b );\cf2\b0 \par
               \cf0 _transitionsAr\b =\b0 ar\b ;\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
\par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Returns transition to specified character (if exists)\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;param name="c"&gt;Character&lt;/param&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;returns&gt;Returns TreeNode or null&lt;/returns&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf0 TreeNode\cf2  \cf0 GetTransition\b (\cf6 char\cf2\b0  \cf0 c\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf6\b return\cf2\b0  \cf0\b (\b0 TreeNode\b )\b0 _transHash\b [\b0 c\b ];\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
\par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Returns true if node contains transition to specified character\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;param name="c"&gt;Character&lt;/param&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;returns&gt;True if transition exists&lt;/returns&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf6\b bool\cf2\b0  \cf0 ContainsTransition\b (\cf6 char\cf2\b0  \cf0 c\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf6\b return\cf2\b0  \cf0 GetTransition\b (\b0 c\b )!=\cf6 null\cf0 ;\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
           \cf9 #endregion\par
\cf2            \cf9 #region Properties\par
\cf2            \par
           \cf6\b private\cf2\b0  \cf6\b char\cf2\b0  \cf0 _char\b ;\cf2\b0 \par
           \cf6\b private\cf2\b0  \cf0 TreeNode\cf2  \cf0 _parent\b ;\cf2\b0 \par
           \cf6\b private\cf2\b0  \cf0 TreeNode\cf2  \cf0 _failure\b ;\cf2\b0 \par
           \cf6\b private\cf2\b0  \cf0 ArrayList\cf2  \cf0 _results\b ;\cf2\b0 \par
           \cf6\b private\cf2\b0  \cf0 TreeNode\b []\cf2\b0  \cf0 _transitionsAr\b ;\cf2\b0 \par
           \cf6\b private\cf2\b0  \cf6\b string\cf0 []\cf2\b0  \cf0 _resultsAr\b ;\cf2\b0 \par
           \cf6\b private\cf2\b0  \cf0 Hashtable\cf2  \cf0 _transHash\b ;\cf2\b0 \par
\par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Character\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf6\b char\cf2\b0  \cf0 Char\cf2 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 get\cf2  \cf0\b \{\cf2\b0  \cf6\b return\cf2\b0  \cf0 _char\b ;\cf2\b0  \cf0\b \}\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
\par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Parent tree node\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf0 TreeNode\cf2  \cf0 Parent\cf2 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 get\cf2  \cf0\b \{\cf2\b0  \cf6\b return\cf2\b0  \cf0 _parent\b ;\cf2\b0  \cf0\b \}\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
\par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Failure function - descendant node\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf0 TreeNode\cf2  \cf0 Failure\cf2 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 get\cf2  \cf0\b \{\cf2\b0  \cf6\b return\cf2\b0  \cf0 _failure\b ;\cf2\b0  \cf0\b \}\cf2\b0 \par
               \cf0 set\cf2  \cf0\b \{\cf2\b0  \cf0 _failure\b =\b0 value\b ;\cf2\b0  \cf0\b \}\cf2\b0  \par
           \cf0\b \}\cf2\b0 \par
\par
\par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Transition function - list of descendant nodes\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf0 TreeNode\b []\cf2\b0  \cf0 Transitions\cf2 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 get\cf2  \cf0\b \{\cf2\b0  \cf6\b return\cf2\b0  \cf0 _transitionsAr\b ;\cf2\b0  \cf0\b \}\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
\par
           \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2            \f1\fs18\cf4 /// Returns list of patterns ending by this letter\par
\f0\fs20\cf2            \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2            \cf6\b public\cf2\b0  \cf6\b string\cf0 []\cf2\b0  \cf0 Results\cf2 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 get\cf2  \cf0\b \{\cf2\b0  \cf6\b return\cf2\b0  \cf0 _resultsAr\b ;\cf2\b0  \cf0\b \}\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
           \cf9 #endregion\par
\cf2        \cf0\b \}\cf2\b0 \par
\par
       \cf9 #endregion\par
\cf2        \cf9 #region Local fields\par
\cf2        \par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Root of keyword tree\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b private\cf2\b0  \cf0 TreeNode\cf2  \cf0 _root\b ;\cf2\b0 \par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Keywords to search for\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b private\cf2\b0  \cf6\b string\cf0 []\cf2\b0  \cf0 _keywords\b ;\cf2\b0 \par
\par
       \cf9 #endregion\par
\cf2 \par
       \cf9 #region Initialization\par
\cf2                \par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Initialize search algorithm (Build keyword tree)\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;param name="keywords"&gt;Keywords to search for&lt;/param&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf0 StringSearch\b (\cf6 string\cf0 []\cf2\b0  \cf0 keywords\b )\cf2\b0 \par
       \cf0\b \{\cf2\b0 \par
           \cf0 Keywords\b =\b0 keywords\b ;\cf2\b0 \par
       \cf0\b \}\cf2\b0 \par
\par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Initialize search algorithm with no keywords\par
\f0\fs20\cf2        \f1\fs18\cf4 /// (Use Keywords property)\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf0 StringSearch\b ()\cf2\b0 \par
       \cf0\b \{\cf2\b0  \cf0\b \}\cf2\b0 \par
\par
       \cf9 #endregion\par
\cf2        \cf9 #region Implementation\par
\cf2 \par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Build tree from specified keywords\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b void\cf2\b0  \cf0 BuildTree\b ()\cf2\b0 \par
       \cf0\b \{\cf2\b0 \par
           \f1\fs18\cf3 // Build keyword tree and transition function\par
\f0\fs20\cf2            \cf0 _root\b =\cf6 new\cf2\b0  \cf0 TreeNode\b (\cf6 null\cf0 ,\cf7\b0 ' '\cf0\b );\cf2\b0 \par
           \cf6\b foreach\cf0 (\cf6 string\cf2\b0  \cf0 p\cf2  \cf6\b in\cf2\b0  \cf0 _keywords\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \f1\fs18\cf3 // add pattern to tree\par
\f0\fs20\cf2                \cf0 TreeNode\cf2  \cf0 nd\b =\b0 _root\b ;\cf2\b0 \par
               \cf6\b foreach\cf0 (\cf6 char\cf2\b0  \cf0 c\cf2  \cf6\b in\cf2\b0  \cf0 p\b )\cf2\b0 \par
               \cf0\b \{\cf2\b0 \par
                   \cf0 TreeNode\cf2  \cf0 ndNew\b =\cf6 null\cf0 ;\cf2\b0 \par
                   \cf6\b foreach\cf0 (\b0 TreeNode\cf2  \cf0 trans\cf2  \cf6\b in\cf2\b0  \cf0 nd\b .\b0 Transitions\b )\cf2\b0 \par
                       \cf6\b if\cf2\b0  \cf0\b (\b0 trans\b .\b0 Char\b ==\b0 c\b )\cf2\b0  \cf0\b \{\cf2\b0  \cf0 ndNew\b =\b0 trans\b ;\cf2\b0  \cf6\b break\cf0 ;\cf2\b0  \cf0\b \}\cf2\b0 \par
\par
                   \cf6\b if\cf2\b0  \cf0\b (\b0 ndNew\b ==\cf6 null\cf0 )\cf2\b0  \par
                   \cf0\b \{\cf2\b0  \par
                       \cf0 ndNew\b =\cf6 new\cf2\b0  \cf0 TreeNode\b (\b0 nd\b ,\b0 c\b );\cf2\b0 \par
                       \cf0 nd\b .\b0 AddTransition\b (\b0 ndNew\b );\cf2\b0 \par
                   \cf0\b \}\cf2\b0 \par
                   \cf0 nd\b =\b0 ndNew\b ;\cf2\b0 \par
               \cf0\b \}\cf2\b0 \par
               \cf0 nd\b .\b0 AddResult\b (\b0 p\b );\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
\par
           \f1\fs18\cf3 // Find failure functions\par
\f0\fs20\cf2            \cf0 ArrayList\cf2  \cf0 nodes\b =\cf6 new\cf2\b0  \cf0 ArrayList\b ();\cf2\b0 \par
           \f1\fs18\cf3 // level 1 nodes - fail to root node\par
\f0\fs20\cf2            \cf6\b foreach\cf0 (\b0 TreeNode\cf2  \cf0 nd\cf2  \cf6\b in\cf2\b0  \cf0 _root\b .\b0 Transitions\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 nd\b .\b0 Failure\b =\b0 _root\b ;\cf2\b0 \par
               \cf6\b foreach\cf0 (\b0 TreeNode\cf2  \cf0 trans\cf2  \cf6\b in\cf2\b0  \cf0 nd\b .\b0 Transitions\b )\cf2\b0  \cf0 nodes\b .\b0 Add\b (\b0 trans\b );\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
           \f1\fs18\cf3 // other nodes - using BFS\par
\f0\fs20\cf2            \cf6\b while\cf0 (\b0 nodes\b .\b0 Count\b !=\cf5\b0 0\cf0\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 ArrayList\cf2  \cf0 newNodes\b =\cf6 new\cf2\b0  \cf0 ArrayList\b ();\cf2\b0 \par
               \cf6\b foreach\cf0 (\b0 TreeNode\cf2  \cf0 nd\cf2  \cf6\b in\cf2\b0  \cf0 nodes\b )\cf2\b0 \par
               \cf0\b \{\cf2\b0 \par
                   \cf0 TreeNode\cf2  \cf0 r\b =\b0 nd\b .\b0 Parent\b .\b0 Failure\b ;\cf2\b0 \par
                   \cf6\b char\cf2\b0  \cf0 c\b =\b0 nd\b .\b0 Char\b ;\cf2\b0 \par
\par
                   \cf6\b while\cf0 (\b0 r\b !=\cf6 null\cf0 &amp;&amp;!\b0 r\b .\b0 ContainsTransition\b (\b0 c\b ))\cf2\b0  \cf0 r\b =\b0 r\b .\b0 Failure\b ;\cf2\b0 \par
                   \cf6\b if\cf2\b0  \cf0\b (\b0 r\b ==\cf6 null\cf0 )\cf2\b0 \par
                       \cf0 nd\b .\b0 Failure\b =\b0 _root\b ;\cf2\b0 \par
                   \cf6\b else\cf2\b0 \par
                   \cf0\b \{\cf2\b0 \par
                       \cf0 nd\b .\b0 Failure\b =\b0 r\b .\b0 GetTransition\b (\b0 c\b );\cf2\b0         \par
                       \cf6\b foreach\cf0 (\cf6 string\cf2\b0  \cf0 result\cf2  \cf6\b in\cf2\b0  \cf0 nd\b .\b0 Failure\b .\b0 Results\b )\cf2\b0 \par
                           \cf0 nd\b .\b0 AddResult\b (\b0 result\b );\cf2\b0 \par
                   \cf0\b \}\cf2\b0 \par
  \par
                   \f1\fs18\cf3 // add child nodes to BFS list \par
\f0\fs20\cf2                    \cf6\b foreach\cf0 (\b0 TreeNode\cf2  \cf0 child\cf2  \cf6\b in\cf2\b0  \cf0 nd\b .\b0 Transitions\b )\cf2\b0 \par
                       \cf0 newNodes\b .\b0 Add\b (\b0 child\b );\cf2\b0 \par
               \cf0\b \}\cf2\b0 \par
               \cf0 nodes\b =\b0 newNodes\b ;\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
           \cf0 _root\b .\b0 Failure\b =\b0 _root\b ;\cf2\b0         \par
       \cf0\b \}\cf2\b0 \par
\par
\par
       \cf9 #endregion\par
\cf2        \cf9 #region Methods &amp; Properties\par
\cf2 \par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Keywords to search for (setting this property is slow, because\par
\f0\fs20\cf2        \f1\fs18\cf4 /// it requieres rebuilding of keyword tree)\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf6\b string\cf0 []\cf2\b0  \cf0 Keywords\cf2 \par
       \cf0\b \{\cf2\b0 \par
           \cf0 get\cf2  \cf0\b \{\cf2\b0  \cf6\b return\cf2\b0  \cf0 _keywords\b ;\cf2\b0  \cf0\b \}\cf2\b0 \par
           \cf0 set\cf2  \par
           \cf0\b \{\cf2\b0 \par
               \cf0 _keywords\b =\b0 value\b ;\cf2\b0  \par
               \cf0 BuildTree\b ();\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
       \cf0\b \}\cf2\b0 \par
\par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Searches passed text and returns all occurrences of any keyword\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;param name="text"&gt;Text to search&lt;/param&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;returns&gt;Array of occurrences&lt;/returns&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf0 StringSearchResult\b []\cf2\b0  \cf0 FindAll\b (\cf6 string\cf2\b0  \cf0 text\b )\cf2\b0 \par
       \cf0\b \{\cf2\b0 \par
           \cf0 ArrayList\cf2  \cf0 ret\b =\cf6 new\cf2\b0  \cf0 ArrayList\b ();\cf2\b0 \par
           \cf0 TreeNode\cf2  \cf0 ptr\b =\b0 _root\b ;\cf2\b0 \par
           \cf6\b int\cf2\b0  \cf0 index\b =\cf5\b0 0\cf0\b ;\cf2\b0 \par
\par
           \cf6\b while\cf0 (\b0 index\b &lt;\b0 text\b .\b0 Length\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 TreeNode\cf2  \cf0 trans\b =\cf6 null\cf0 ;\cf2\b0 \par
               \cf6\b while\cf0 (\b0 trans\b ==\cf6 null\cf0 )\cf2\b0 \par
               \cf0\b \{\cf2\b0 \par
                   \cf0 trans\b =\b0 ptr\b .\b0 GetTransition\b (\b0 text\b [\b0 index\b ]);\cf2\b0 \par
                   \cf6\b if\cf2\b0  \cf0\b (\b0 ptr\b ==\b0 _root\b )\cf2\b0  \cf6\b break\cf0 ;\cf2\b0 \par
                   \cf6\b if\cf2\b0  \cf0\b (\b0 trans\b ==\cf6 null\cf0 )\cf2\b0  \cf0 ptr\b =\b0 ptr\b .\b0 Failure\b ;\cf2\b0 \par
               \cf0\b \}\cf2\b0 \par
               \cf6\b if\cf2\b0  \cf0\b (\b0 trans\b !=\cf6 null\cf0 )\cf2\b0  \cf0 ptr\b =\b0 trans\b ;\cf2\b0 \par
\par
               \cf6\b foreach\cf0 (\cf6 string\cf2\b0  \cf0 found\cf2  \cf6\b in\cf2\b0  \cf0 ptr\b .\b0 Results\b )\cf2\b0 \par
                   \cf0 ret\b .\b0 Add\b (\cf6 new\cf2\b0  \cf0 StringSearchResult\b (\b0 index\b -\b0 found\b .\b0 Length\b +\cf5\b0 1\cf0\b ,\b0 found\b ));\cf2\b0 \par
               \cf0 index\b ++;\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
           \cf6\b return\cf2\b0  \cf0\b (\b0 StringSearchResult\b [])\b0 ret\b .\b0 ToArray\b (\cf6 typeof\cf0 (\b0 StringSearchResult\b ));\cf2\b0 \par
       \cf0\b \}\cf2\b0 \par
\par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Searches passed text and returns first occurrence of any keyword\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;param name="text"&gt;Text to search&lt;/param&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;returns&gt;First occurrence of any keyword (or StringSearchResult.Empty if text doesn't contain any keyword)&lt;/returns&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf0 StringSearchResult\cf2  \cf0 FindFirst\b (\cf6 string\cf2\b0  \cf0 text\b )\cf2\b0 \par
       \cf0\b \{\cf2\b0 \par
           \cf0 ArrayList\cf2  \cf0 ret\b =\cf6 new\cf2\b0  \cf0 ArrayList\b ();\cf2\b0 \par
           \cf0 TreeNode\cf2  \cf0 ptr\b =\b0 _root\b ;\cf2\b0 \par
           \cf6\b int\cf2\b0  \cf0 index\b =\cf5\b0 0\cf0\b ;\cf2\b0 \par
\par
           \cf6\b while\cf0 (\b0 index\b &lt;\b0 text\b .\b0 Length\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 TreeNode\cf2  \cf0 trans\b =\cf6 null\cf0 ;\cf2\b0 \par
               \cf6\b while\cf0 (\b0 trans\b ==\cf6 null\cf0 )\cf2\b0 \par
               \cf0\b \{\cf2\b0 \par
                   \cf0 trans\b =\b0 ptr\b .\b0 GetTransition\b (\b0 text\b [\b0 index\b ]);\cf2\b0 \par
                   \cf6\b if\cf2\b0  \cf0\b (\b0 ptr\b ==\b0 _root\b )\cf2\b0  \cf6\b break\cf0 ;\cf2\b0 \par
                   \cf6\b if\cf2\b0  \cf0\b (\b0 trans\b ==\cf6 null\cf0 )\cf2\b0  \cf0 ptr\b =\b0 ptr\b .\b0 Failure\b ;\cf2\b0 \par
               \cf0\b \}\cf2\b0 \par
               \cf6\b if\cf2\b0  \cf0\b (\b0 trans\b !=\cf6 null\cf0 )\cf2\b0  \cf0 ptr\b =\b0 trans\b ;\cf2\b0 \par
\par
               \cf6\b foreach\cf0 (\cf6 string\cf2\b0  \cf0 found\cf2  \cf6\b in\cf2\b0  \cf0 ptr\b .\b0 Results\b )\cf2\b0 \par
                   \cf6\b return\cf2\b0  \cf6\b new\cf2\b0  \cf0 StringSearchResult\b (\b0 index\b -\b0 found\b .\b0 Length\b +\cf5\b0 1\cf0\b ,\b0 found\b );\cf2\b0 \par
               \cf0 index\b ++;\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
           \cf6\b return\cf2\b0  \cf0 StringSearchResult\b .\b0 Empty\b ;\cf2\b0 \par
       \cf0\b \}\cf2\b0 \par
\par
\par
       \f1\fs18\cf4 /// &lt;summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// Searches passed text and returns true if text contains any keyword\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;/summary&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;param name="text"&gt;Text to search&lt;/param&gt;\par
\f0\fs20\cf2        \f1\fs18\cf4 /// &lt;returns&gt;True when text contains any keyword&lt;/returns&gt;\par
\f0\fs20\cf2        \cf6\b public\cf2\b0  \cf6\b bool\cf2\b0  \cf0 ContainsAny\b (\cf6 string\cf2\b0  \cf0 text\b )\cf2\b0 \par
       \cf0\b \{\cf2\b0 \par
           \cf0 TreeNode\cf2  \cf0 ptr\b =\b0 _root\b ;\cf2\b0 \par
           \cf6\b int\cf2\b0  \cf0 index\b =\cf5\b0 0\cf0\b ;\cf2\b0 \par
\par
           \cf6\b while\cf0 (\b0 index\b &lt;\b0 text\b .\b0 Length\b )\cf2\b0 \par
           \cf0\b \{\cf2\b0 \par
               \cf0 TreeNode\cf2  \cf0 trans\b =\cf6 null\cf0 ;\cf2\b0 \par
               \cf6\b while\cf0 (\b0 trans\b ==\cf6 null\cf0 )\cf2\b0 \par
               \cf0\b \{\cf2\b0 \par
                   \cf0 trans\b =\b0 ptr\b .\b0 GetTransition\b (\b0 text\b [\b0 index\b ]);\cf2\b0 \par
                   \cf6\b if\cf2\b0  \cf0\b (\b0 ptr\b ==\b0 _root\b )\cf2\b0  \cf6\b break\cf0 ;\cf2\b0 \par
                   \cf6\b if\cf2\b0  \cf0\b (\b0 trans\b ==\cf6 null\cf0 )\cf2\b0  \cf0 ptr\b =\b0 ptr\b .\b0 Failure\b ;\cf2\b0 \par
               \cf0\b \}\cf2\b0 \par
               \cf6\b if\cf2\b0  \cf0\b (\b0 trans\b !=\cf6 null\cf0 )\cf2\b0  \cf0 ptr\b =\b0 trans\b ;\cf2\b0 \par
\par
               \cf6\b if\cf2\b0  \cf0\b (\b0 ptr\b .\b0 Results\b .\b0 Length\b &gt;\cf5\b0 0\cf0\b )\cf2\b0  \cf6\b return\cf2\b0  \cf6\b true\cf0 ;\cf2\b0 \par
               \cf0 index\b ++;\cf2\b0 \par
           \cf0\b \}\cf2\b0 \par
           \cf6\b return\cf2\b0  \cf6\b false\cf0 ;\cf2\b0 \par
       \cf0\b \}\cf2\b0 \par
\par
       \cf9 #endregion\par
\cf2    \cf0\b \}\cf2\b0 \par
\cf0\b \}\cf2\b0 \par
}</value>
  </data>
</root>